# -*- coding: utf-8 -*-
"""Backtesting v1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uXjH_sRhAYbMRKtPE-uaVypGkZ7CXoqW
"""

import streamlit as st
import pandas as pd
import ccxt
import backtrader as bt
from datetime import datetime, timezone
import plotly.graph_objects as go

# --- 1. –ö–ª–∞—Å—Å –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ (—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏) ---
class DcaGridStrategy(bt.Strategy):
    params = (
        ('initial_order_size', 100.0), ('safety_order_size', 100.0),
        ('price_step_percent', 2.0), ('price_step_multiplier', 1.5),
        ('safety_orders_count', 10), ('take_profit_percent', 2.0),
        ('is_futures', False), ('leverage', 1), ('funding_rate', 0.0001),
    )

    def __init__(self):
        self.entry_price = 0; self.total_cost = 0; self.total_size = 0
        self.take_profit_price = 0; self.liquidation_price = 0
        self.safety_orders_placed = 0
        self.trades = []
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ª–∏–∫–≤–∏–¥–∞—Ü–∏–∏
        self.liquidated = False

        if self.p.is_futures:
            self.add_timer(when=bt.Timer.SESSION_START, offset=bt.timedelta(hours=8), repeat=bt.timedelta(hours=8))

    def notify_timer(self, timer, when, *args):
        funding_fee = self.broker.get_value() * self.p.funding_rate
        self.broker.add_cash(-funding_fee)

    def notify_order(self, order):
        if order.status == order.Completed:
            trade_info = {
                'dt': bt.num2date(order.executed.dt),
                'price': order.executed.price,
                'size': order.executed.size
            }
            if order.isbuy():
                self.total_cost += order.executed.value
                self.total_size += order.executed.size
                self.entry_price = self.total_cost / self.total_size
                self.take_profit_price = self.entry_price * (1 + self.p.take_profit_percent / 100)
                if self.p.is_futures:
                    self.liquidation_price = self.entry_price * (1 - (0.99 / self.p.leverage))
                trade_info['type'] = 'buy'
                self.trades.append(trade_info)
            elif order.issell():
                self.reset_cycle()
                trade_info['type'] = 'sell'
                self.trades.append(trade_info)

    def next(self):
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –ï—Å–ª–∏ –º—ã –ª–∏–∫–≤–∏–¥–∏—Ä–æ–≤–∞–Ω—ã, –±–æ–ª—å—à–µ –Ω–µ —Ç–æ—Ä–≥—É–µ–º
        if self.liquidated:
            return

        if self.p.is_futures and self.position and self.data.close[0] <= self.liquidation_price:
            self.log(f'!!! LIQUIDATION at Price: {self.data.close[0]:.2f}. Liquidation Price was: {self.liquidation_price:.2f} !!!')
            self.close()
            self.liquidated = True # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –ª–∏–∫–≤–∏–¥–∞—Ü–∏–∏
            return

        if not self.position:
            self.start_new_cycle()
            return

        if self.position and self.data.close[0] >= self.take_profit_price:
            self.sell(size=self.position.size)

        if self.safety_orders_placed < self.p.safety_orders_count:
            step = self.p.price_step_percent / 100.0 * (self.p.price_step_multiplier ** self.safety_orders_placed)
            next_safety_price = self.entry_price * (1 - step)
            if self.data.close[0] <= next_safety_price:
                order_size = self.p.safety_order_size / self.data.close[0]
                self.buy(size=order_size)
                self.safety_orders_placed += 1

    def start_new_cycle(self):
        self.buy(size=self.p.initial_order_size / self.data.close[0])

    def reset_cycle(self):
        self.total_cost = 0; self.total_size = 0; self.safety_orders_placed = 0

    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        st.write(f'{dt.isoformat()} - {txt}')

# --- 2. –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–∞–Ω–Ω—ã—Ö –∏ –Ω–æ–≤–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞ ---
@st.cache_data
def fetch_data(exchange_name, symbol, timeframe, start_date):
    # (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –æ—Å—Ç–∞–ª—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    try:
        exchange = getattr(ccxt, exchange_name)()
        since = int(start_date.replace(tzinfo=timezone.utc).timestamp() * 1000)
        all_ohlcv = []
        while True:
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=1000)
            if not ohlcv: break
            all_ohlcv.extend(ohlcv)
            since = ohlcv[-1][0] + 1
        df = pd.DataFrame(all_ohlcv, columns=['datetime', 'open', 'high', 'low', 'close', 'volume'])
        df['datetime'] = pd.to_datetime(df['datetime'], unit='ms')
        df.set_index('datetime', inplace=True)
        return df
    except Exception as e:
        st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return None

# –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 1: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞
def plot_interactive_chart(data_df, trades):
    fig = go.Figure(data=[go.Candlestick(x=data_df.index,
                                           open=data_df['open'],
                                           high=data_df['high'],
                                           low=data_df['low'],
                                           close=data_df['close'],
                                           name='–¶–µ–Ω–∞')])
    buys = [t for t in trades if t['type'] == 'buy']
    sells = [t for t in trades if t['type'] == 'sell']

    fig.add_trace(go.Scatter(x=[t['dt'] for t in buys], y=[t['price'] for t in buys],
                             mode='markers', name='–ü–æ–∫—É–ø–∫–∏ (Buy)',
                             marker=dict(color='green', size=10, symbol='triangle-up')))

    fig.add_trace(go.Scatter(x=[t['dt'] for t in sells], y=[t['price'] for t in sells],
                             mode='markers', name='–ü—Ä–æ–¥–∞–∂–∏ (Sell)',
                             marker=dict(color='red', size=10, symbol='triangle-down')))

    fig.update_layout(title='–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ —Ü–µ–Ω—ã –∏ —Å–¥–µ–ª–æ–∫',
                      xaxis_title='–î–∞—Ç–∞',
                      yaxis_title='–¶–µ–Ω–∞',
                      xaxis_rangeslider_visible=True,
                      template='plotly_dark')
    return fig

PRESETS = {
    "okx": {"Spot": {"BTC/USDT": "BTC-USDT"}, "Futures": {"BTC/USDT": "BTC-USDT-SWAP"}},
    "bitmex": {"Futures": {"XBT/USDT": "XBTUSDT"}}
}

# --- 3. –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å Streamlit ---
st.set_page_config(layout="wide", initial_sidebar_state="expanded")
st.title("üìà –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –±—ç–∫—Ç–µ—Å—Ç–µ—Ä –¥–ª—è —Å–µ—Ç–æ—á–Ω–æ–π DCA-—Å—Ç—Ä–∞—Ç–µ–≥–∏–∏")

with st.sidebar:
    st.header("‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –±—ç–∫—Ç–µ—Å—Ç–∞")
    exchange = st.selectbox("–ë–∏—Ä–∂–∞", list(PRESETS.keys()))
    instrument = st.selectbox("–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç", list(PRESETS[exchange].keys()))

    available_pairs = list(PRESETS[exchange][instrument].keys())
    if not available_pairs:
        symbol_display = st.text_input("–¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ (—Ç–∏–∫–µ—Ä CCXT)", "BTC-USDT-SWAP")
    else:
        symbol_display = st.selectbox("–¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞", available_pairs)

    symbol_ccxt = PRESETS[exchange][instrument].get(symbol_display, symbol_display)

    timeframe = st.selectbox("–¢–∞–π–º—Ñ—Ä–µ–π–º", ['1d', '4h', '1h'])
    start_date = st.date_input("–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞", datetime(2023, 1, 1))
    initial_cash = st.number_input("–ù–∞—á–∞–ª—å–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª", value=10000.0)

    st.header("üõ†Ô∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏")
    initial_order_size = st.number_input("–ù–∞—á–∞–ª—å–Ω—ã–π –æ—Ä–¥–µ—Ä ($)", value=100.0)
    safety_order_size = st.number_input("–°—Ç—Ä–∞—Ö–æ–≤–æ—á–Ω—ã–π –æ—Ä–¥–µ—Ä ($)", value=100.0)
    safety_orders_count = st.number_input("Max trigger number", value=10)
    price_step_percent = st.number_input("Grid step (%)", value=2.0)
    price_step_multiplier = st.number_input("Grid step ratio (%)", value=1.5)
    take_profit_percent = st.number_input("Take Profit (%)", value=2.0)

    # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 3: –ö–∞—Å—Ç–æ–º–Ω—ã–µ –∫–æ–º–∏—Å—Å–∏–∏
    st.header("üí∞ –ö–æ–º–∏—Å—Å–∏–∏ –∏ –ø–ª–µ—á–æ")
    is_futures = (instrument == "Futures")
    use_custom_commissions = st.checkbox("–£—á–∏—Ç—ã–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∫–æ–º–∏—Å—Å–∏–∏ –∏ –ø–ª–µ—á–æ")
    commission = 0.001 # 0.1% –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    leverage = 1
    if use_custom_commissions:
        if is_futures:
            st.markdown("<p style='color:orange;'>–£–∫–∞–∂–∏—Ç–µ –∫–æ–º–∏—Å—Å–∏–∏ –¥–ª—è —Ñ—å—é—á–µ—Ä—Å–æ–≤:</p>", unsafe_allow_html=True)
            commission = st.number_input("–ö–æ–º–∏—Å—Å–∏—è –º–µ–π–∫–µ—Ä–∞/—Ç–µ–π–∫–µ—Ä–∞ (%)", value=0.05, format="%.4f") / 100.0
            leverage = st.slider("–ü–ª–µ—á–æ (Leverage)", 1, 100, 10)
        else:
            st.markdown("<p style='color:orange;'>–£–∫–∞–∂–∏—Ç–µ –∫–æ–º–∏—Å—Å–∏—é –¥–ª—è —Å–ø–æ—Ç–∞:</p>", unsafe_allow_html=True)
            commission = st.number_input("–ö–æ–º–∏—Å—Å–∏—è (%)", value=0.1, format="%.4f") / 100.0

if st.sidebar.button("üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –±—ç–∫—Ç–µ—Å—Ç"):
    start_datetime = datetime.combine(start_date, datetime.min.time())

    with st.spinner(f"–ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol_ccxt} —Å {exchange}..."):
        data_df = fetch_data(exchange, symbol_ccxt, timeframe, start_datetime)

    if data_df is not None and not data_df.empty:
        st.success("–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.")
        data_feed = bt.feeds.PandasData(dataname=data_df)

        cerebro = bt.Cerebro()
        cerebro.adddata(data_feed)
        strategy = cerebro.addstrategy(DcaGridStrategy,
                            is_futures=is_futures, leverage=leverage, **st.session_state)

        cerebro.broker.set_cash(initial_cash)
        cerebro.broker.setcommission(commission=commission, leverage=leverage if is_futures else None)

        log_container = st.expander("–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –ª–æ–≥ —Å–¥–µ–ª–æ–∫", expanded=False)

        start_value = cerebro.broker.getvalue()
        results = cerebro.run()
        end_value = cerebro.broker.getvalue()

        st.header("üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã")
        pnl = end_value - start_value
        col1, col2 = st.columns(2)
        with col1:
            st.metric("–ù–∞—á–∞–ª—å–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª", f"${start_value:,.2f}")
        with col2:
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 4: –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å—Ç—Ä–µ–ª–æ—á–∫–∞ –¥–ª—è —É–±—ã—Ç–∫–∞
            st.metric("–ö–æ–Ω–µ—á–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª", f"${end_value:,.2f}", delta=pnl)

        st.subheader("–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫")
        fig = plot_interactive_chart(data_df, results[0].trades)
        st.plotly_chart(fig, use_container_width=True)