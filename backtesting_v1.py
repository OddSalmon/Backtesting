# -*- coding: utf-8 -*-
"""Backtesting v1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uXjH_sRhAYbMRKtPE-uaVypGkZ7CXoqW
"""

import streamlit as st
import pandas as pd
import ccxt
import backtrader as bt
from datetime import datetime, timezone

# --- 1. ÐšÐ»Ð°ÑÑ Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸ Ð´Ð»Ñ Backtrader ---
# Ð›Ð¾Ð³Ð¸ÐºÐ° ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð±Ð¾Ñ‚Ð° Ð¾ÑÑ‚Ð°ÐµÑ‚ÑÑ Ñ‚Ð°ÐºÐ¾Ð¹ Ð¶Ðµ, ÐºÐ°Ðº Ð¸ Ñ€Ð°Ð½ÑŒÑˆÐµ.
class DcaGridStrategy(bt.Strategy):
    params = (
        ('initial_order_size', 10.0),
        ('safety_order_size', 10.0),
        ('price_step_percent', 1.0),
        ('price_step_multiplier', 1.5),
        ('safety_orders_count', 20),
        ('take_profit_percent', 1.0),
    )

    def __init__(self):
        self.entry_price = 0
        self.total_cost = 0
        self.total_size = 0
        self.take_profit_price = 0
        self.last_safety_price = 0
        self.safety_orders_placed = 0

    def start(self):
        initial_size = self.p.initial_order_size / self.data.close[0]
        self.buy(size=initial_size)
        self.log(f'INITIAL BUY: {initial_size:.4f} @ {self.data.close[0]:.2f}')
        self.last_safety_price = self.data.close[0]

    def notify_order(self, order):
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'BUY EXECUTED: Size {order.executed.size:.4f}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}')
                self.total_cost += order.executed.value
                self.total_size += order.executed.size
                self.entry_price = self.total_cost / self.total_size
                self.take_profit_price = self.entry_price * (1 + self.p.take_profit_percent / 100)
            elif order.issell():
                self.log(f'SELL EXECUTED (TAKE PROFIT): Size {order.executed.size:.4f}, Price: {order.executed.price:.2f}, PnL: {order.executed.pnl:.2f}')
                self.total_cost = 0
                self.total_size = 0
                self.safety_orders_placed = 0

    def next(self):
        if self.position and self.data.close[0] >= self.take_profit_price:
            self.sell(size=self.position.size)
            self.log(f'TAKE PROFIT ORDER PLACED at {self.data.close[0]:.2f}')

        if self.safety_orders_placed < self.p.safety_orders_count:
            step = self.p.price_step_percent / 100.0 * (self.p.price_step_multiplier ** self.safety_orders_placed)
            next_safety_price = self.last_safety_price * (1 - step)
            if self.data.close[0] <= next_safety_price:
                order_size = self.p.safety_order_size / self.data.close[0]
                self.buy(size=order_size)
                self.log(f'SAFETY ORDER PLACED: {self.safety_orders_placed + 1} at {self.data.close[0]:.2f}')
                self.last_safety_price = self.data.close[0]
                self.safety_orders_placed += 1

    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        st.write(f'{dt.isoformat()} - {txt}')

# --- 2. Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ‡ÐµÑ€ÐµÐ· CCXT ---
def fetch_data(exchange_name, symbol, timeframe, start_date, end_date):
    try:
        exchange_class = getattr(ccxt, exchange_name)
        exchange = exchange_class()

        start_ts = int(start_date.replace(tzinfo=timezone.utc).timestamp() * 1000)
        end_ts = int(end_date.replace(tzinfo=timezone.utc).timestamp() * 1000)

        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since=start_ts, limit=5000)
        if not ohlcv:
            return None

        df = pd.DataFrame(ohlcv, columns=['datetime', 'open', 'high', 'low', 'close', 'volume'])
        df['datetime'] = pd.to_datetime(df['datetime'], unit='ms')
        df.set_index('datetime', inplace=True)
        return df
    except Exception as e:
        st.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐµ Ð´Ð°Ð½Ð½Ñ‹Ñ…: {e}")
        return None

# --- 3. Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ Streamlit ---
st.set_page_config(layout="wide")
st.title("ðŸ“ˆ Ð‘ÑÐºÑ‚ÐµÑÑ‚ÐµÑ€ Ð´Ð»Ñ ÑÐµÑ‚Ð¾Ñ‡Ð½Ð¾Ð¹ DCA-ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸ Ð½Ð° CCXT")

with st.sidebar:
    st.header("âš™ï¸ ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð±ÑÐºÑ‚ÐµÑÑ‚Ð°")
    exchange_name = st.selectbox("Ð‘Ð¸Ñ€Ð¶Ð°", ['binance', 'bybit', 'okx', 'kucoin', 'gateio'])
    symbol = st.text_input("Ð¢Ð¾Ñ€Ð³Ð¾Ð²Ð°Ñ Ð¿Ð°Ñ€Ð°", "BTC/USDT")
    timeframe = st.selectbox("Ð¢Ð°Ð¹Ð¼Ñ„Ñ€ÐµÐ¹Ð¼", ['1d', '4h', '1h', '30m', '15m', '5m'])
    start_date = st.date_input("Ð”Ð°Ñ‚Ð° Ð½Ð°Ñ‡Ð°Ð»Ð°", datetime(2023, 1, 1))
    end_date = st.date_input("Ð”Ð°Ñ‚Ð° Ð¾ÐºÐ¾Ð½Ñ‡Ð°Ð½Ð¸Ñ", datetime.now())
    initial_cash = st.number_input("ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»", value=10000.0)

    st.header("ðŸ› ï¸ ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸")
    initial_order_size = st.number_input("ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¾Ñ€Ð´ÐµÑ€ ($)", value=100.0)
    safety_order_size = st.number_input("Ð¡Ñ‚Ñ€Ð°Ñ…Ð¾Ð²Ð¾Ñ‡Ð½Ñ‹Ð¹ Ð¾Ñ€Ð´ÐµÑ€ ($)", value=100.0)
    safety_orders_count = st.number_input("Max trigger number", value=10)
    price_step_percent = st.number_input("Grid step (%)", value=2.0)
    price_step_multiplier = st.number_input("Grid step ratio (%)", value=1.5)
    take_profit_percent = st.number_input("Take Profit (%)", value=2.0)

if st.sidebar.button("ðŸš€ Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð±ÑÐºÑ‚ÐµÑÑ‚"):
    with st.spinner(f"Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ {exchange_name}..."):
        # ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÐ¼ Ð´Ð°Ñ‚Ñ‹ Ð² datetime Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹ Ð´Ð»Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
        start_datetime = datetime.combine(start_date, datetime.min.time())
        end_datetime = datetime.combine(end_date, datetime.max.time())

        data_df = fetch_data(exchange_name, symbol, timeframe, start_datetime, end_datetime)

    if data_df is not None and not data_df.empty:
        st.success(f"Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ {symbol} ({timeframe}) ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹.")
        data_feed = bt.feeds.PandasData(dataname=data_df)

        cerebro = bt.Cerebro()
        cerebro.adddata(data_feed)
        cerebro.addstrategy(DcaGridStrategy,
                            initial_order_size=initial_order_size,
                            safety_order_size=safety_order_size,
                            safety_orders_count=safety_orders_count,
                            price_step_percent=price_step_percent,
                            price_step_multiplier=price_step_multiplier,
                            take_profit_percent=take_profit_percent)

        cerebro.broker.set_cash(initial_cash)

        st.header("ðŸ“‹ Ð›Ð¾Ð³ ÑÐ´ÐµÐ»Ð¾Ðº")
        start_value = cerebro.broker.getvalue()
        cerebro.run()
        end_value = cerebro.broker.getvalue()

        st.header("ðŸ“Š Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»", f"${start_value:,.2f}")
        with col2:
            st.metric("ÐšÐ¾Ð½ÐµÑ‡Ð½Ñ‹Ð¹ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»", f"${end_value:,.2f}", delta=f"${end_value - start_value:,.2f}")

        st.subheader("Ð“Ñ€Ð°Ñ„Ð¸Ðº")
        fig = cerebro.plot(style='candlestick', barup='green', bardown='red')[0][0]
        st.pyplot(fig)