# -*- coding: utf-8 -*-
"""Backtesting v1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uXjH_sRhAYbMRKtPE-uaVypGkZ7CXoqW
"""

import streamlit as st
import pandas as pd
import ccxt
import backtrader as bt
from datetime import datetime, timezone

# --- 1. –ö–ª–∞—Å—Å –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è Backtrader (–° –ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ô –õ–û–ì–ò–ö–û–ô) ---
class DcaGridStrategy(bt.Strategy):
    params = (
        ('initial_order_size', 10.0),
        ('safety_order_size', 10.0),
        ('price_step_percent', 1.0),
        ('price_step_multiplier', 1.5),
        ('safety_orders_count', 20),
        ('take_profit_percent', 1.0),
    )

    def __init__(self):
        self.entry_price = 0
        self.total_cost = 0
        self.total_size = 0
        self.take_profit_price = 0
        self.safety_orders_placed = 0

    def notify_order(self, order):
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'BUY EXECUTED: Size {order.executed.size:.4f}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}')
                self.total_cost += order.executed.value
                self.total_size += order.executed.size
                self.entry_price = self.total_cost / self.total_size
                self.take_profit_price = self.entry_price * (1 + self.p.take_profit_percent / 100)
            elif order.issell():
                self.log(f'SELL EXECUTED (TAKE PROFIT): Size {order.executed.size:.4f}, Price: {order.executed.price:.2f}, PnL: {order.executed.pnl:.2f}')
                # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
                self.total_cost = 0
                self.total_size = 0
                self.safety_orders_placed = 0

    def next(self):
        # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –õ–æ–≥–∏–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ —Ä—ã–Ω–æ–∫ ---
        # –ï—Å–ª–∏ –º—ã –Ω–µ –≤ –ø–æ–∑–∏—Ü–∏–∏, –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π —Ü–∏–∫–ª —Å –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
        if not self.position:
            initial_size = self.p.initial_order_size / self.data.close[0]
            self.buy(size=initial_size)
            self.log(f'NEW CYCLE STARTED: Initial Buy {initial_size:.4f} @ {self.data.close[0]:.2f}')
            return # –í—ã—Ö–æ–¥–∏–º, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—Ä—É–≥–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫ –Ω–∞ —ç—Ç–æ–π —Å–≤–µ—á–µ

        # --- –õ–æ–≥–∏–∫–∞ Take Profit ---
        if self.position and self.data.close[0] >= self.take_profit_price:
            self.sell(size=self.position.size)
            self.log(f'TAKE PROFIT ORDER PLACED at {self.data.close[0]:.2f}')

        # --- –õ–æ–≥–∏–∫–∞ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–∞—Ö–æ–≤–æ—á–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤ ---
        # –°—á–∏—Ç–∞–µ–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—Ç —Å—Ä–µ–¥–Ω–µ–π —Ü–µ–Ω—ã –≤—Ö–æ–¥–∞, –∞ –Ω–µ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ä–¥–µ—Ä–∞
        if self.safety_orders_placed < self.p.safety_orders_count:
            step = self.p.price_step_percent / 100.0 * (self.p.price_step_multiplier ** self.safety_orders_placed)
            next_safety_price = self.entry_price * (1 - step)

            if self.data.close[0] <= next_safety_price:
                order_size = self.p.safety_order_size / self.data.close[0]
                self.buy(size=order_size)
                self.log(f'SAFETY ORDER PLACED: {self.safety_orders_placed + 1} at {self.data.close[0]:.2f}')
                self.safety_orders_placed += 1

    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º st.empty() –¥–ª—è –≤—ã–≤–æ–¥–∞ –ª–æ–≥–æ–≤ –≤ –æ–¥–∏–Ω –±–ª–æ–∫ —Å –ø—Ä–æ–∫—Ä—É—Ç–∫–æ–π
        log_container.write(f'{dt.isoformat()} - {txt}')


# --- 2. –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ CCXT ---
@st.cache_data
def fetch_data(exchange_name, symbol, timeframe, start_date, end_date):
    try:
        exchange_class = getattr(ccxt, exchange_name)
        exchange = exchange_class()

        start_ts = int(start_date.replace(tzinfo=timezone.utc).timestamp() * 1000)

        all_ohlcv = []
        while start_ts < int(end_date.replace(tzinfo=timezone.utc).timestamp() * 1000):
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since=start_ts, limit=1000)
            if not ohlcv:
                break
            all_ohlcv.extend(ohlcv)
            start_ts = ohlcv[-1][0] + 1

        if not all_ohlcv: return None

        df = pd.DataFrame(all_ohlcv, columns=['datetime', 'open', 'high', 'low', 'close', 'volume'])
        df['datetime'] = pd.to_datetime(df['datetime'], unit='ms')
        df.set_index('datetime', inplace=True)
        return df
    except Exception as e:
        st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return None

# --- 3. –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å Streamlit ---
st.set_page_config(layout="wide")
st.title("üìà –ë—ç–∫—Ç–µ—Å—Ç–µ—Ä –¥–ª—è —Å–µ—Ç–æ—á–Ω–æ–π DCA-—Å—Ç—Ä–∞—Ç–µ–≥–∏–∏")

with st.sidebar:
    st.header("‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –±—ç–∫—Ç–µ—Å—Ç–∞")
    # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –±–∏—Ä–∂–∏ ---
    exchange_name = st.selectbox("–ë–∏—Ä–∂–∞", ['okx', 'bmex'])
    symbol = st.text_input("–¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞", "BTC/USDT")
    timeframe = st.selectbox("–¢–∞–π–º—Ñ—Ä–µ–π–º", ['1d', '4h', '1h', '30m', '15m', '5m'])
    start_date = st.date_input("–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞", datetime(2023, 1, 1))
    end_date = st.date_input("–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è", datetime.now())
    initial_cash = st.number_input("–ù–∞—á–∞–ª—å–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª", value=10000.0, step=1000.0)

    st.header("üõ†Ô∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏")
    initial_order_size = st.number_input("–ù–∞—á–∞–ª—å–Ω—ã–π –æ—Ä–¥–µ—Ä ($)", value=100.0)
    safety_order_size = st.number_input("–°—Ç—Ä–∞—Ö–æ–≤–æ—á–Ω—ã–π –æ—Ä–¥–µ—Ä ($)", value=100.0)
    safety_orders_count = st.number_input("Max trigger number", value=10)
    price_step_percent = st.number_input("Grid step (%)", value=2.0)
    price_step_multiplier = st.number_input("Grid step ratio (%)", value=1.5)
    take_profit_percent = st.number_input("Take Profit (%)", value=2.0)

if st.sidebar.button("üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –±—ç–∫—Ç–µ—Å—Ç"):
    start_datetime = datetime.combine(start_date, datetime.min.time())
    end_datetime = datetime.combine(end_date, datetime.max.time())

    with st.spinner(f"–ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å {exchange_name}..."):
        data_df = fetch_data(exchange_name, symbol, timeframe, start_datetime, end_datetime)

    if data_df is not None and not data_df.empty:
        st.success(f"–î–∞–Ω–Ω—ã–µ –¥–ª—è {symbol} ({timeframe}) —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.")
        data_feed = bt.feeds.PandasData(dataname=data_df)

        cerebro = bt.Cerebro()
        cerebro.adddata(data_feed)
        cerebro.addstrategy(DcaGridStrategy,
                            initial_order_size=initial_order_size,
                            safety_order_size=safety_order_size,
                            safety_orders_count=safety_orders_count,
                            price_step_percent=price_step_percent,
                            price_step_multiplier=price_step_multiplier,
                            take_profit_percent=take_profit_percent)

        cerebro.broker.set_cash(initial_cash)
        cerebro.broker.setcommission(commission=0.001) # –ö–æ–º–∏—Å—Å–∏—è 0.1%

        st.header("üìã –õ–æ–≥ —Å–¥–µ–ª–æ–∫")
        log_container = st.expander("–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –ª–æ–≥", expanded=False)

        start_value = cerebro.broker.getvalue()
        cerebro.run()
        end_value = cerebro.broker.getvalue()

        st.header("üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã")
        col1, col2 = st.columns(2)
        with col1:
            st.metric("–ù–∞—á–∞–ª—å–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª", f"${start_value:,.2f}")
        with col2:
            st.metric("–ö–æ–Ω–µ—á–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª", f"${end_value:,.2f}", delta=f"${end_value - start_value:,.2f}")

        st.subheader("–ì—Ä–∞—Ñ–∏–∫")
        fig = cerebro.plot(style='candlestick', barup='green', bardown='red')[0][0]
        st.pyplot(fig)